---
sidebar_position: 10
title: VRF
slug: .
description: Learn how to use Verifiable Random Functions with Switchboard
keywords: [Switchboard, Solana, VRF, randomness, verifiable, proof]
---

import MarkdownImage from "/src/components/MarkdownImage";
import RandomnessInstructions from "/api/idl/_randomness_instructions.mdx";
import {
  Typography,
  IconButton,
  Box,
  CardActionArea,
  Card,
  CardContent,
} from "@mui/material";
import Link from "@docusaurus/Link";
import GitHubIcon from "@mui/icons-material/GitHub";
import VrfAccountData from "/api/idl/accounts/VrfAccountData.md";
import VrfInit from "/api/idl/instructions/vrfInit.md";
import VrfProve from "/api/idl/instructions/vrfProve.md";
import VrfVerify from "/api/idl/instructions/vrfVerify.md";
import VrfRequestRandomness from "/api/idl/instructions/vrfRequestRandomness.md";

import CallbackZC from "/api/idl/types/CallbackZC.md";

:::caution

While Switchboard V2's oracle network is fully audited, the VRF implementation is currently unaudited software. Please use at your own risk.

:::

A VRF account is an on-chain account that holds the latest VRF value, as well as its owners specified callback function. When a VRF account owner requests a new randomness value, the oracle queue delegates the update request to an oracle based on its round robin ordering of oracles heartbeating on-chain. The oracle submits its VRF seed on-chain, then must submit 276 transactions to turn the state machine, which computes the proof. When the proof is computed and successfully validates the pseudo-random value, the oracle invokes the account owner‚Äôs callback instruction.

The VRF function return a **_u8[32]_** buffer that can be transmuted to most data types using the [bytemuck crate](https://crates.io/crates/bytemuck).

```rust
let result_buffer: [u8; 32];
// get result buffer from parsed VRF Account
msg!("Result buffer is {:?}", result_buffer);
let value: &[u128] = bytemuck::cast_slice(&result_buffer[..]);
msg!("u128 buffer {:?}", value);
let result = value[0] % max_result as u128;
msg!("Current VRF Value [0 - {}) = {}!", max_result, result);
```

## Queue Configuration

### ‚öôÔ∏èunpermissionedVrfEnabled

A VRF Account must be created for a specific `oracleQueue` and cannot be changed. If the VRF Account's `oracleQueue` has `unpermissionedVrfEnabled` disabled, the VRF Account will need to initialize a Permission Account and be granted `PERMIT_VRF_REQUESTS` permissions from the queue `authority` before being able to request randomness from a queue's oracles.

## Functions

A VRF Account is responsible for the following functions:

- [**Callback**](#callback): Define the callback cpi instruction that will be executed when a new randomness value is produced on-chain.
- [**Oracle Rewards**](#reward-oracles): Rewards oracles 0.1 wSOL for successfully completing an update request.

### üöÄCallback

When creating a VRF Account, the VRF `authority` should specify a `callback` function that will be called by the oracle. VRF Accounts should ensure their `callback` function consumes less than ~160k compute units or it may fail to complete.

<CallbackZC />

### üöÄReward Oracles

When a VRF Account requests a new random value from a queue, it transfers 0.1 wSOL to it's `escrow` wallet. An oracle receives 90% of the reward when it verifies the proof on-chain and the remaining 10% if the callback succeeds.

## Account Schema

### üì¶VrfAccountData

<VrfAccountData />

## More Info

You can view the full VRF walk-through in the example repo:

<!---
<Link to="https://github.com/switchboard-xyz/vrf-cpi-example">
  <IconButton
    component="span"
    color="primary"
    aria-label="example repo"
    to="https://github.com/switchboard-xyz/vrf-cpi-example"
  >
    <GitHubIcon fontSize="large" />
  </IconButton>
  <Typography component="span">@switchboard-xyz/vrf-cpi-Example</Typography>
</Link>
--->

- <Link
    className="link__nocolor"
    to="https://github.com/switchboard-xyz/vrf-cpi-example"
  >
    ‚ÑπÔ∏è @switchboard-xyz/vrf-cpi-example
  </Link>
