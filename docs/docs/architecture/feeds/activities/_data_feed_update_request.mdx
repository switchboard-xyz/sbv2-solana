import MarkdownImage from "/src/components/MarkdownImage";
import { Typography } from "@mui/material";
import AggregatorOpenRound from "/api/idl/instructions/aggregatorOpenRound.md";
import CrankPop from "/api/idl/instructions/crankPop.md";

The following diagram depicts how a data feed update request gets processed by Switchboard. First, any user turns the crank. The crank is a collection of aggregator pubkeys, ordered by their next available update time. If an aggregator is ready for an update, the crank turner gets rewarded with the queue's specified `reward`.

The oracle queue assigns the next N oracles based on the aggregator's specified `oracleRequestBatchSize`. Each oracle deserializes an aggregators job accounts, executes the tasks, and saves the result on-chain.

If enough oracles respond as specified by an aggregator's `minOracleResults`, then the value is accepted on-chain and the oracles receive the queue's specified `reward`.

If the `minOracleResults` fail to respond, then no value is accepted and the feed update failure is recorded on-chain in the aggregator's `consecutiveFailureCount`.

<!-- TODO: Update with instruction names -->

<MarkdownImage img="/img/update_request_activity.png" />

<details>
<summary>

<Typography sx={{ fontWeight: "bold" }} variant="h6">
  CrankPop
</Typography>

<b>Cost: </b>5000 lamports

</summary>

<CrankPop />

</details>

<details>
<summary>

<Typography sx={{ fontWeight: "bold" }} variant="h6">
  CrankPop
</Typography>

<b>Cost: </b>5000 lamports

</summary>

<CrankPop />

</details>

<details>
<summary>

<Typography sx={{ fontWeight: "bold" }} variant="h6">
  AggregatorOpenRound
</Typography>

<b>Cost: </b>5000 lamports

</summary>

<AggregatorOpenRound />

</details>
