{
  "folderName": "accounts",
  "folderPath": ".autodoc/docs/json/javascript/solana.js/src/accounts",
  "url": "https://github.com/switchboard-xyz/sbv2-solana/tree/master/.autodoc/docs/json/javascript/solana.js/src/accounts",
  "files": [
    {
      "fileName": "account.ts",
      "filePath": "javascript/solana.js/src/accounts/account.ts",
      "url": "https://github.com/switchboard-xyz/sbv2-solana/blob/master/javascript/solana.js/src/accounts/account.ts",
      "summary": "This code defines an abstract class `Account` and various types and constants related to different account types in the `sbv2-solana` project. The `Account` class serves as a base class for different types of on-chain accounts, providing a constructor to initialize the account with a `SwitchboardProgram` instance and a public key, as well as abstract methods for retrieving the account size and loading the account data.\n\nThe code also defines a callback type `OnAccountChangeCallback` for handling updates to deserialized account data. Several account data types are imported from the `generated` module, and corresponding account classes are imported from other modules within the project.\n\nA constant `BUFFER_DISCRIMINATOR` is defined to identify buffer accounts, and two type aliases, `SwitchboardAccountType` and `SwitchboardAccount`, are created to represent the different account types in the project. Another type alias, `SwitchboardAccountData`, is defined to represent the data associated with these accounts.\n\nFinally, a `DISCRIMINATOR_MAP` is created to map discriminators (unique identifiers) to their corresponding account types. This map is useful for determining the type of an account based on its discriminator.\n\nIn the larger project, these account classes and types are used to interact with on-chain resources, such as oracles, aggregators, and jobs. For example, an `AggregatorAccount` instance can be used to load and manipulate data related to an aggregator on the Solana blockchain:\n\n```javascript\nconst aggregatorAccount = new AggregatorAccount(switchboardProgram, publicKey);\nconst aggregatorData = await aggregatorAccount.loadData();\n```\n\nThis code snippet demonstrates how to create an `AggregatorAccount` instance and load its associated data from the blockchain.",
      "questions": "1. **Question:** What is the purpose of the `Account` abstract class and its methods `size` and `loadData`?\n   **Answer:** The `Account` abstract class serves as a base class for different types of accounts in the sbv2-solana project. The `size` method is an abstract method that should return the on-chain account size when implemented in derived classes. The `loadData` method is also an abstract method that should retrieve and decode the data in the account when implemented in derived classes.\n\n2. **Question:** What is the purpose of the `OnAccountChangeCallback` type and how is it used in the code?\n   **Answer:** The `OnAccountChangeCallback` type is a callback function type that takes deserialized account data as an argument. It is meant to be called when the account data is updated on-chain. However, it is not used directly in this code file, but it is exported for use in other parts of the project.\n\n3. **Question:** What is the purpose of the `DISCRIMINATOR_MAP` constant and how is it used in the code?\n   **Answer:** The `DISCRIMINATOR_MAP` constant is a map that associates discriminators (unique identifiers) with their corresponding `SwitchboardAccountType`. It is used to map the discriminators to their respective account types, making it easier to identify and work with different account types in the project."
    },
    {
      "fileName": "aggregatorHistoryBuffer.ts",
      "filePath": "javascript/solana.js/src/accounts/aggregatorHistoryBuffer.ts",
      "url": "https://github.com/switchboard-xyz/sbv2-solana/blob/master/javascript/solana.js/src/accounts/aggregatorHistoryBuffer.ts",
      "summary": "The `AggregatorHistoryBuffer` class in this code represents a round-robin buffer of historical samples for an aggregator account. It provides methods to create, decode, and fetch historical data from the buffer. This is useful for tracking the history of data points in an aggregator account, such as price feeds or other time-series data.\n\nThe `AggregatorHistoryBuffer` class has several methods:\n\n- `default(size)`: Returns a history buffer account initialized with default values and the specified size.\n- `decode(historyBuffer)`: Decodes a history buffer and returns an array of historical samples in ascending order by timestamp.\n- `fromAggregator(program, aggregator)`: Returns an aggregator's assigned history buffer or undefined if it doesn't exist.\n- `loadData()`: Fetches an aggregator's history buffer and returns an array of historical samples.\n- `onChange(callback, commitment)`: Invokes a callback each time an AggregatorAccount's data has changed on-chain.\n- `createInstructions(program, payer, params)`: Creates a transaction object that will create the AggregatorHistoryBuffer.\n- `create(program, params)`: Creates a history buffer for an aggregator and stores the last N samples in a round-robin history buffer.\n- `collectMetrics(history, minUpdateDelaySeconds, period)`: Collects various metrics from the history buffer, such as average value, standard deviation, and update coefficient.\n\nHere's a basic usage example:\n\n```ts\nimport { AggregatorAccount, AggregatorHistoryBuffer } from '@switchboard-xyz/solana.js';\nconst aggregatorAccount = new AggregatorAccount(program, aggregatorKey);\nconst aggregator = await aggregatorAccount.loadData();\nconst [historyBuffer, addHistorySignature] = await AggregatorHistoryBuffer.create(program, {\n   aggregatorAccount,\n   maxSamples: 10000,\n});\nconst history = await historyBuffer.loadData();\n```\n\nIn this example, an `AggregatorAccount` is loaded, and a new `AggregatorHistoryBuffer` is created with a maximum of 10,000 samples. The historical data is then fetched from the buffer.",
      "questions": "1. **Question:** How does the `AggregatorHistoryBuffer` class handle the storage and retrieval of historical samples in a round-robin manner?\n   **Answer:** The `AggregatorHistoryBuffer` class stores historical samples in a buffer with a fixed size, determined by the `maxSamples` parameter. When decoding the history buffer, it splits the buffer into two parts: the front and the tail. The front contains samples after the insert index, while the tail contains samples before the insert index. The final decoded history is obtained by concatenating the front and tail arrays, ensuring a round-robin order of samples.\n\n2. **Question:** What is the purpose of the `collectMetrics` method in the `AggregatorHistoryBuffer` class, and what kind of metrics does it return?\n   **Answer:** The `collectMetrics` method is used to calculate various metrics related to the historical samples stored in the aggregator history buffer. It returns an object containing metrics such as the actual period, number of samples, average update delay, update coefficient, average value, standard deviation, and the minimum and maximum samples within the specified period.\n\n3. **Question:** How does the `createInstructions` method in the `AggregatorHistoryBuffer` class work, and what is its role in creating a new history buffer for an aggregator?\n   **Answer:** The `createInstructions` method generates a set of transaction instructions and signers required to create a new history buffer for an aggregator. It takes the `SwitchboardProgram`, payer, and history buffer configuration parameters as input. The method creates a new account for the history buffer, sets the space and lamports required, and associates it with the aggregator account. It returns a tuple containing the new `AggregatorHistoryBuffer` instance and a `TransactionObject` containing the generated instructions and signers."
    },
    {
      "fileName": "bufferRelayAccount.ts",
      "filePath": "javascript/solana.js/src/accounts/bufferRelayAccount.ts",
      "url": "https://github.com/switchboard-xyz/sbv2-solana/blob/master/javascript/solana.js/src/accounts/bufferRelayAccount.ts",
      "summary": "The `BufferRelayerAccount` class in this code represents an account type that holds a buffer of data sourced from a single `JobAccount`. It has no consensus mechanism and relies on trusting an `OracleAccount` to respond honestly. The buffer relayer has a maximum capacity of 500 bytes.\n\nThe class provides several methods to interact with the buffer relayer account, such as creating a new account, loading an existing account, and invoking a callback when the account's data changes on-chain. It also provides methods to open a round, save the result of a round, and save the result synchronously.\n\nFor example, to create a new buffer relayer account, you can use the `BufferRelayerAccount.create()` method, which takes several parameters such as the name, minimum update delay, queue account, authority, and job account. This method returns a new `BufferRelayerAccount` instance and a transaction signature.\n\nTo open a round, you can use the `BufferRelayerAccount.openRound()` method, which takes an optional parameter object containing the token wallet, buffer relayer, queue account, and queue. This method returns a transaction signature.\n\nTo save the result of a round, you can use the `BufferRelayerAccount.saveResult()` method, which takes a parameter object containing the result and success status. This method returns a transaction signature.\n\nThe `BufferRelayerAccount` class also provides utility methods to fetch and parse account data, get permission accounts, and get escrow accounts. These methods can be used to interact with the buffer relayer account and its associated accounts in the larger sbv2-solana project.",
      "questions": "1. **Question**: What is the purpose of the `BufferRelayerAccount` class and how does it relate to the other imported classes like `JobAccount`, `OracleAccount`, and `QueueAccount`?\n   \n   **Answer**: The `BufferRelayerAccount` class represents an account type that holds a buffer of data sourced from its sole `JobAccount`. It relies on trusting an `OracleAccount` to respond honestly and has a max capacity of 500 bytes. The `QueueAccount` is used to manage the queue of oracles that interact with the `BufferRelayerAccount`.\n\n2. **Question**: How does the `createInstructions` method work and what are the required parameters for creating a new `BufferRelayerAccount`?\n\n   **Answer**: The `createInstructions` method is used to generate the instructions required to create a new `BufferRelayerAccount` on the Solana blockchain. The required parameters include `name`, `minUpdateDelaySeconds`, `queueAccount`, `authority`, `jobAccount`, and an optional `keypair`.\n\n3. **Question**: What is the purpose of the `openRound` and `saveResult` methods in the `BufferRelayerAccount` class?\n\n   **Answer**: The `openRound` method is used to open a new round for the buffer relayer, transferring the required tokens to the escrow account. The `saveResult` method is used to save the result of the buffer relayer's operation, indicating whether it was successful or not."
    },
    {
      "fileName": "crankAccount.ts",
      "filePath": "javascript/solana.js/src/accounts/crankAccount.ts",
      "url": "https://github.com/switchboard-xyz/sbv2-solana/blob/master/javascript/solana.js/src/accounts/crankAccount.ts",
      "summary": "The `CrankAccount` class in this code is responsible for managing a priority queue of aggregators and their next available update time. This scheduling mechanism ensures that `AggregatorAccount`s are updated as close as possible to their specified update interval.\n\nThe class provides several methods to interact with the crank account, such as `load`, `loadData`, `createInstructions`, `create`, `pushInstruction`, `push`, `popInstruction`, `pop`, `peakNextWithTime`, `peakNextReady`, `peakNext`, `loadCrank`, `isOnCrank`, `fetchAccounts`, and `toAccountsJSON`.\n\nFor example, the `create` method creates a new `CrankAccount` and initializes it with the provided parameters. The `push` method pushes a new aggregator onto the crank, while the `pop` method pops the next readily updateable aggregator from the crank.\n\nThe `peakNextWithTime` method returns an array of the next aggregator pubkeys to be popped from the crank, limited by a specified number. The `peakNextReady` method returns an array of the next readily updateable aggregator pubkeys to be popped from the crank, limited by a specified number.\n\nHere's an example of how to create a new `CrankAccount`:\n\n```javascript\nconst [crankAccount, txnSignature] = await CrankAccount.create(\n  program,\n  {\n    queueAccount: queueAccountInstance,\n    name: 'exampleCrank',\n    metadata: 'exampleMetadata',\n    maxRows: 500,\n  }\n);\n```\n\nAnd here's an example of how to push an aggregator onto the crank:\n\n```javascript\nconst txnSignature = await crankAccount.push({\n  aggregatorAccount: aggregatorAccountInstance,\n});\n```\n\nThis code is part of a larger project that deals with managing and updating data feeds on the Solana blockchain. The `CrankAccount` class plays a crucial role in scheduling updates for these data feeds.",
      "questions": "1. **Question**: What is the purpose of the `CrankAccount` class and how does it relate to the `AggregatorAccount` class?\n\n   **Answer**: The `CrankAccount` class represents an account holding a priority queue of aggregators and their next available update time. It acts as a scheduling mechanism to ensure `AggregatorAccount` instances are updated as close as possible to their specified update interval.\n\n2. **Question**: How does the `peakNextReady` function work and what does it return?\n\n   **Answer**: The `peakNextReady` function returns an array of the next readily updateable aggregator public keys to be popped from the crank, limited by the given number `num`. It filters the aggregator public keys based on whether their next available update timestamp is less than or equal to the current Unix timestamp.\n\n3. **Question**: What are the `CrankInitParams`, `CrankPushParams`, and `CrankPopParams` interfaces used for?\n\n   **Answer**: These interfaces define the parameters required for various operations on the `CrankAccount` class. `CrankInitParams` is used for initializing a `CrankAccount`, `CrankPushParams` is used for pushing an aggregator onto the crank, and `CrankPopParams` is used for popping an element from the crank."
    },
    {
      "fileName": "crankDataBuffer.ts",
      "filePath": "javascript/solana.js/src/accounts/crankDataBuffer.ts",
      "url": "https://github.com/switchboard-xyz/sbv2-solana/blob/master/javascript/solana.js/src/accounts/crankDataBuffer.ts",
      "summary": "The `CrankDataBuffer` class in this code is responsible for managing a priority queue of aggregator accounts and their next available update times. The class is part of the `sbv2-solana` project and interacts with the Solana blockchain using the `@solana/web3.js` and `@coral-xyz/anchor` libraries.\n\nThe `CrankDataBuffer` class extends the `Account` class and holds an array of `types.CrankRow` objects. Each `CrankRow` object contains an aggregator account's public key and its next available update time. The class provides methods to interact with the priority queue, such as loading data from the blockchain, decoding the data, and sorting the queue.\n\nThe `onChange` method allows users to subscribe to changes in the crank's buffer on the blockchain. It takes a callback function as an argument, which is invoked whenever the buffer changes. The method also accepts an optional `commitment` parameter to specify the desired transaction finality.\n\nThe `loadData` method retrieves and decodes the `types.CrankAccountData` stored in the account. It returns an array of `types.CrankRow` objects representing the priority queue.\n\nThe `decode` method is a static method that takes an `AccountInfo<Buffer>` object and returns an array of `types.CrankRow` objects. It processes the buffer data and extracts the public keys and next available update times for each aggregator account.\n\nThe `getAccountSize` and `default` static methods are utility functions that help with buffer size calculations and creating default buffer data, respectively.\n\nThe `sort` method is a static method that takes an array of `types.CrankRow` objects and returns a sorted array based on the next available update times.\n\nThe `fromCrank` static method takes a `SwitchboardProgram` object and a `types.CrankAccountData` object, and returns a `CrankDataBuffer` object associated with the given crank account data.\n\nThe `pqPop` function is a utility function used internally by the `sort` method to sort the priority queue. It takes an array of `types.CrankRow` objects and returns the next item in the sorted order.",
      "questions": "1. **Question:** What is the purpose of the `CrankDataBuffer` class and how does it relate to the `types.CrankRow` type?\n   **Answer:** The `CrankDataBuffer` class represents an account holding a priority queue of aggregators and their next available update time. It is used to store, retrieve, and manipulate an array of `types.CrankRow` objects, which contain the public key of an aggregator and its next available update time.\n\n2. **Question:** How does the `onChange` method work and when should it be used?\n   **Answer:** The `onChange` method is used to invoke a callback each time a crank's buffer has changed on-chain. It takes a callback function as an argument, which is called when the crank's buffer changes, and an optional commitment level for transaction finality. This method is useful for monitoring changes to the crank's buffer in real-time.\n\n3. **Question:** What is the purpose of the `pqPop` function and how does it relate to the `CrankDataBuffer` class?\n   **Answer:** The `pqPop` function is a utility function used to remove and return the highest priority item (with the lowest nextTimestamp) from an array of `types.CrankRow` objects. It is used internally by the `CrankDataBuffer` class in the `sort` method to sort the crank rows based on their priority."
    },
    {
      "fileName": "index.ts",
      "filePath": "javascript/solana.js/src/accounts/index.ts",
      "url": "https://github.com/switchboard-xyz/sbv2-solana/blob/master/javascript/solana.js/src/accounts/index.ts",
      "summary": "This code is part of the `sbv2-solana` project and serves as an entry point for importing various account-related modules. The purpose of this code is to provide a convenient way to access all the account classes and their functionalities in a single import statement. This helps in maintaining a clean and organized codebase for the larger project.\n\nThe code exports several account classes and their associated functionalities:\n\n1. `account`: Contains the base account class, which other account classes inherit from.\n2. `aggregatorAccount`: Manages the aggregator account, responsible for collecting and aggregating data from multiple oracles.\n3. `aggregatorHistoryBuffer`: Handles the storage and retrieval of historical data for the aggregator account.\n4. `bufferRelayAccount`: Manages the buffer relay account, which is responsible for relaying data between different accounts.\n5. `crankAccount`: Handles the crank account, which is responsible for processing queued jobs and updating the state of the system.\n6. `crankDataBuffer`: Manages the storage and retrieval of data for the crank account.\n7. `jobAccount`: Handles the job account, which is responsible for managing and executing jobs in the system.\n8. `leaseAccount`: Manages the lease account, which is responsible for leasing resources in the system.\n9. `oracleAccount`: Handles the oracle account, which is responsible for providing data to the aggregator account.\n10. `permissionAccount`: Manages the permission account, which is responsible for controlling access to various resources in the system.\n11. `programStateAccount`: Handles the program state account, which is responsible for maintaining the overall state of the system.\n12. `queueAccount`: Manages the queue account, which is responsible for managing and processing job queues.\n13. `queueDataBuffer`: Handles the storage and retrieval of data for the queue account.\n14. `vrfAccount`: Manages the VRF (Verifiable Random Function) account, which is responsible for generating random numbers in a verifiable manner.\n15. `vrfLiteAccount`: Handles the VRF Lite account, which is a lightweight version of the VRF account.\n16. `vrfPoolAccount`: Manages the VRF Pool account, which is responsible for maintaining a pool of VRF accounts.\n\nTo use any of these account classes in another part of the project, you can simply import them using a single import statement:\n\n```javascript\nimport { AggregatorAccount, OracleAccount } from 'sbv2-solana';\n```\n\nThis will give you access to the `AggregatorAccount` and `OracleAccount` classes, which can be used to create and manage aggregator and oracle accounts, respectively.",
      "questions": "1. **What is the purpose of each exported module in this code?**\n\n   Each module represents a different account or data structure used in the `sbv2-solana` project, and exporting them allows other parts of the project to import and use these modules as needed.\n\n2. **How are these modules used in the overall `sbv2-solana` project?**\n\n   These modules are likely used to manage various aspects of the project, such as managing accounts, handling data buffers, and interacting with oracles, VRFs, and other components. They are imported and utilized by other parts of the project to perform specific tasks.\n\n3. **Are there any dependencies or external libraries required for these modules to function correctly?**\n\n   It is not clear from this code snippet alone if there are any dependencies or external libraries required for these modules. To determine this, one would need to examine the individual module files and check for any imports or references to external libraries."
    },
    {
      "fileName": "jobAccount.ts",
      "filePath": "javascript/solana.js/src/accounts/jobAccount.ts",
      "url": "https://github.com/switchboard-xyz/sbv2-solana/blob/master/javascript/solana.js/src/accounts/jobAccount.ts",
      "summary": "The `JobAccount` class in this code is responsible for managing Switchboard Jobs, which are tasks that dictate how to source data off-chain. The class provides methods to create, load, and decode job accounts, as well as to fetch multiple job accounts.\n\nThe `JobAccount` class extends the `Account` class and is parameterized with the `types.JobAccountData` type. It has static methods like `getName`, `getMetadata`, `getAccountSize`, `default`, and `createMock` that help in retrieving job account properties, calculating account size, and creating mock accounts for testing purposes.\n\nThe `load` method is used to load an existing `JobAccount` with its current on-chain state. The `loadData` method retrieves and decodes the `types.JobAccountData` stored in the account. The `createInstructions` method generates instructions for creating a new job account, while the `create` method creates a new job account and returns the account and transaction signatures.\n\nThe `decode` method is used to decode the job account data, and the `decodeJob` method decodes the `OracleJob` from the account data. The `toAccountsJSON` method converts the job account data to a JSON format, and the `fetchMultiple` method fetches multiple job accounts based on the provided public keys.\n\nHere's an example of creating a new job account:\n\n```javascript\nconst [jobAccount, txSignatures] = await JobAccount.create(\n  program,\n  {\n    data: new Uint8Array([...]),\n    name: 'exampleJob',\n    expiration: 100,\n  },\n  { confirmations: 1 }\n);\n```\n\nIn the larger project, the `JobAccount` class is used to manage job accounts in the Switchboard ecosystem, which is a decentralized oracle network built on the Solana blockchain.",
      "questions": "1. **Question:** What is the purpose of the `JobAccount` class and how does it relate to the SwitchboardTasks and OracleJob?\n\n   **Answer:** The `JobAccount` class represents an account type that stores a list of SwitchboardTasks (`OracleJob.Task`) which dictate how to source data off-chain. It provides methods to interact with and manage the on-chain state of a job account, including loading, creating, and decoding the job account data.\n\n2. **Question:** How does the `createInstructions` method work and what are the limitations on the job data size?\n\n   **Answer:** The `createInstructions` method generates the instructions required to create a new `JobAccount` on-chain. It takes into account the size of the job data and splits it into chunks if it exceeds the `CHUNK_SIZE` (800 bytes). However, the total job data size must be less than 6400 bytes, otherwise, an error will be thrown.\n\n3. **Question:** How does the `fetchMultiple` method work and what is its purpose?\n\n   **Answer:** The `fetchMultiple` method retrieves multiple job accounts and their associated data given an array of public keys. It returns an array of objects containing the `JobAccount`, its decoded data (`types.JobAccountData`), and the decoded OracleJob. This method is useful for fetching and processing multiple job accounts at once."
    },
    {
      "fileName": "leaseAccount.ts",
      "filePath": "javascript/solana.js/src/accounts/leaseAccount.ts",
      "url": "https://github.com/switchboard-xyz/sbv2-solana/blob/master/javascript/solana.js/src/accounts/leaseAccount.ts",
      "summary": "The `LeaseAccount` class in this code represents an account type for an AggregatorAccount's pre-funded escrow, which is used to reward OracleAccounts for responding to open round requests. The class provides methods to create, load, and manage LeaseAccounts, as well as to interact with associated accounts such as QueueAccount, AggregatorAccount, and JobAccount.\n\nThe `LeaseAccount` class has several methods for creating and initializing LeaseAccounts, such as `createInstructions`, `create`, and `load`. These methods allow users to create a LeaseAccount with specified parameters, fund it with wrapped tokens, and load an existing LeaseAccount with its current on-chain state.\n\nThe `extendInstruction` and `extend` methods allow users to extend a LeaseAccount by funding it with additional tokens. The `withdrawInstruction` and `withdraw` methods enable users to withdraw tokens from a LeaseAccount, either to a specified wallet or by unwrapping the tokens.\n\nThe `estimatedLeaseTimeRemaining` method estimates the time remaining on a given lease based on the oracleRequestBatchSize, minUpdateDelaySeconds, queueReward, and leaseBalance.\n\nThe `fetchAllAccounts` method fetches all associated accounts for a LeaseAccount, including the QueueAccount, AggregatorAccount, JobAccount, and wallets for job authorities.\n\nExample usage:\n\n```ts\nimport { LeaseAccount } from '@switchboard-xyz/solana.js';\nconst [leaseAccount, leaseInitSignature] = await LeaseAccount.create(program, {\n  queueAccount,\n  aggregatorAccount,\n  fundAmount: 1,\n  funderAuthority: null,\n  funderTokenWallet: null,\n  disableWrap: false,\n  withdrawAuthority: null,\n  jobPubkeys: null,\n  jobAuthorities: null,\n});\nconst lease = await leaseAccount.loadData();\n```\n\nThis code is part of a larger project that interacts with the Switchboard decentralized oracle network on the Solana blockchain.",
      "questions": "1. **Question:** What is the purpose of the `LeaseAccount` class and its methods?\n   **Answer:** The `LeaseAccount` class represents an AggregatorAccount's pre-funded escrow used to reward OracleAccounts for responding to open round requests. It provides methods to create, load, extend, withdraw, and set authority for a LeaseAccount, as well as fetch account information and estimate the time remaining on a lease.\n\n2. **Question:** How does the `createInstructions` method work and what are its parameters?\n   **Answer:** The `createInstructions` method creates instructions to initialize a LeaseAccount and optionally funds it with wrapped tokens. It takes a SwitchboardProgram instance, a payer PublicKey, and a set of parameters including aggregatorAccount, queueAccount, jobAuthorities, jobPubkeys, withdrawAuthority, and others. It returns a tuple containing the LeaseAccount and the corresponding TransactionObject.\n\n3. **Question:** How does the `estimatedLeaseTimeRemaining` method work and what does it return?\n   **Answer:** The `estimatedLeaseTimeRemaining` method estimates the time remaining on a given lease based on the oracleRequestBatchSize, minUpdateDelaySeconds, queueReward, and leaseBalance. It returns a tuple containing the number of milliseconds left in the lease and the estimated end date."
    },
    {
      "fileName": "oracleAccount.ts",
      "filePath": "javascript/solana.js/src/accounts/oracleAccount.ts",
      "url": "https://github.com/switchboard-xyz/sbv2-solana/blob/master/javascript/solana.js/src/accounts/oracleAccount.ts",
      "summary": "The `OracleAccount` class in this code represents an oracle account in the sbv2-solana project. An oracle is a server that facilitates the flow of information between the internet and a blockchain, and is rewarded for responding with the honest majority. The `OracleAccount` class holds an oracle's configuration, including the authority, reward/slashing wallet, and a set of metrics tracking its reliability.\n\nThe class provides several methods to interact with the oracle account, such as creating a new oracle account, loading an existing oracle account, staking tokens, withdrawing tokens, and sending heartbeat transactions. It also provides utility methods to fetch the oracle's balance, decode the account data, and subscribe to account changes.\n\nFor example, to create a new oracle account, you can use the `OracleAccount.create()` method, which takes a set of parameters like the queue account, name, metadata, authority, and staking wallet keypair. This method returns a new `OracleAccount` instance and an array of transaction signatures.\n\nTo stake tokens in an oracle account, you can use the `stake()` method, which takes a set of parameters like the stake amount, funder token wallet, and funder authority. This method returns a transaction signature.\n\nTo send a heartbeat transaction, you can use the `heartbeat()` method, which takes optional parameters like the queue account, token wallet, queue authority, and permission. This method returns a transaction signature.\n\nThe `OracleAccount` class also provides methods to fetch multiple oracle accounts and convert the account data to JSON format for easier consumption. Overall, this class plays a crucial role in managing oracle accounts within the sbv2-solana project.",
      "questions": "1. **Question**: How does the `OracleAccount` class handle the creation of mock accounts for testing purposes?\n   **Answer**: The `OracleAccount` class provides a static method `createMock` that takes a `programId`, a partial `data` object of type `types.OracleAccountData`, and an optional `options` object. It creates a mock account by merging the default values with the provided data and returns an `AccountInfo<Buffer>` object with the necessary fields for testing purposes.\n\n2. **Question**: How does the `OracleAccount` class handle staking and unstaking of tokens for an oracle?\n   **Answer**: The `OracleAccount` class provides methods `stakeInstructions` and `withdrawInstruction` to handle staking and unstaking of tokens. The `stakeInstructions` method creates a `TransactionObject` for transferring the specified stake amount from the funder's token wallet to the oracle's staking wallet. The `withdrawInstruction` method creates a `TransactionObject` for withdrawing the specified amount from the oracle's staking wallet to the specified withdraw account or unwrapping the funds directly to the oracle authority.\n\n3. **Question**: How does the `OracleAccount` class handle the heartbeat functionality for an oracle?\n   **Answer**: The `OracleAccount` class provides a method `heartbeat` that takes an optional `params` object and a `TransactionObjectOptions` object. It first loads the necessary data, such as the oracle, queue, and permission accounts, and then creates a `TransactionObject` with the `heartbeatInstruction` method. The `heartbeatInstruction` method creates a transaction instruction for the oracle heartbeat using the provided parameters. Finally, the `heartbeat` method sends the transaction using the `signAndSend` method of the `SwitchboardProgram` instance."
    },
    {
      "fileName": "permissionAccount.ts",
      "filePath": "javascript/solana.js/src/accounts/permissionAccount.ts",
      "url": "https://github.com/switchboard-xyz/sbv2-solana/blob/master/javascript/solana.js/src/accounts/permissionAccount.ts",
      "summary": "The `PermissionAccount` class in this code is responsible for managing permissions between a granter and a grantee in the sbv2-solana project. It is used to dictate the level of permissions between these two entities. A `QueueAccount` acts as the granter, and the grantee can be an `AggregatorAccount`, `BufferRelayerAccount`, or `VrfAccount`. The permissions are represented by the `types.SwitchboardPermission` enumeration.\n\nThe class provides methods to create, load, and set permissions for a `PermissionAccount`. The `create` method initializes a new `PermissionAccount` on the blockchain, while the `load` method retrieves an existing `PermissionAccount` and decodes its data. The `set` method is used to enable or disable specific permissions for a grantee.\n\nFor example, to create a new `PermissionAccount`:\n\n```javascript\nconst [account, txSignature] = await PermissionAccount.create(program, {\n  granter: granterPublicKey,\n  grantee: granteePublicKey,\n  authority: authorityPublicKey,\n});\n```\n\nTo load an existing `PermissionAccount`:\n\n```javascript\nconst [account, state, bump] = await PermissionAccount.load(\n  program,\n  authorityPublicKey,\n  granterPublicKey,\n  granteePublicKey\n);\n```\n\nTo set permissions for a grantee:\n\n```javascript\nconst txnSignature = await account.set({\n  enable: true,\n  permission: new PermitOracleHeartbeat(),\n});\n```\n\nAdditionally, the class provides utility methods such as `isPermissionEnabled`, which checks if a specific permission is enabled, and `getGranteePermissions`, which returns the appropriate `SwitchboardPermission` for a given grantee account.\n\nOverall, the `PermissionAccount` class is a crucial component in managing permissions between different entities in the sbv2-solana project, ensuring that the correct level of access is granted to each participant.",
      "questions": "1. **Question:** How does the `PermissionAccount` class handle different types of permissions for a grantee?\n\n   **Answer:** The `PermissionAccount` class handles different types of permissions for a grantee by using the `getPermissions` static method, which takes a `permission` object as input and returns the corresponding `SwitchboardPermissionKind` object based on the permission's discriminator.\n\n2. **Question:** How can a developer create a new `PermissionAccount` and initialize it with the required parameters?\n\n   **Answer:** A developer can create a new `PermissionAccount` by calling the `PermissionAccount.create` static method, which takes a `SwitchboardProgram` instance and a `PermissionAccountInitParams` object containing the `granter`, `grantee`, and `authority` public keys as input. This method returns a Promise that resolves to a tuple containing the created `PermissionAccount` instance and the transaction signature.\n\n3. **Question:** How can a developer check if a specific permission is enabled on a `PermissionAccount` instance?\n\n   **Answer:** A developer can check if a specific permission is enabled on a `PermissionAccount` instance by calling the `isPermissionEnabled` method with the desired permission as input. This method returns a Promise that resolves to a boolean value indicating whether the specified permission is enabled or not."
    },
    {
      "fileName": "programStateAccount.ts",
      "filePath": "javascript/solana.js/src/accounts/programStateAccount.ts",
      "url": "https://github.com/switchboard-xyz/sbv2-solana/blob/master/javascript/solana.js/src/accounts/programStateAccount.ts",
      "summary": "The `ProgramStateAccount` class in this code represents the global program state for the Switchboard project. It provides methods to interact with the on-chain state, such as loading the current state, creating a mock account for testing, and initializing the program state account if it doesn't exist.\n\nThe `load` method retrieves the current on-chain state of the `ProgramStateAccount` and returns it as a `types.SbState` object. The `loadData` method is used internally by the `load` method to fetch and decode the `types.SbState` stored in the account.\n\nThe `getOrCreate` method retrieves the `ProgramStateAccount` and creates it if it doesn't exist. It takes an optional `params` object with `mint`, `daoMint`, and `vaultKeypair` properties. If the account doesn't exist, it initializes the account with the provided parameters or default values. The method returns a tuple containing the `ProgramStateAccount`, bump, and an optional `TransactionSignature`.\n\nThe `vaultTransfer` method transfers tokens from the program vault to a specified account. It takes the recipient's public key, the vault authority's keypair, and an object with `stateBump` and `amount` properties. The method returns a `TransactionSignature`.\n\nHere's an example of using the `ProgramStateAccount` class:\n\n```javascript\nconst program = new SwitchboardProgram(...);\n\n// Load or create the ProgramStateAccount\nconst [account, bump, txnSignature] = await ProgramStateAccount.getOrCreate(program);\n\n// Load the current state\nconst [loadedAccount, state] = await ProgramStateAccount.load(program, account.publicKey);\n\n// Transfer tokens from the vault\nconst recipientPublicKey = ...;\nconst authorityKeypair = ...;\nconst transferAmount = new anchor.BN(1000);\nconst transferSignature = await ProgramStateAccount.vaultTransfer(\n  program,\n  recipientPublicKey,\n  authorityKeypair,\n  { stateBump: bump, amount: transferAmount }\n);\n```\n\nIn the larger project, the `ProgramStateAccount` class is used to manage the global state of the Switchboard program, including token transfers and account initialization.",
      "questions": "1. **Question**: What is the purpose of the `ProgramStateAccount` class and how does it interact with the Switchboard global program state?\n   **Answer**: The `ProgramStateAccount` class represents the Switchboard global program state and provides methods to interact with it. It allows loading, creating, and updating the program state, as well as transferring tokens from the program vault to a specified account.\n\n2. **Question**: How does the `getOrCreate` method work and what are the possible return values?\n   **Answer**: The `getOrCreate` method retrieves the `ProgramStateAccount` and creates it if it doesn't exist. It returns a tuple containing the `ProgramStateAccount`, the bump value, and a `TransactionSignature` if a transaction was executed during the creation process, or `undefined` if the account already exists.\n\n3. **Question**: What is the purpose of the `vaultTransfer` method and what are its parameters?\n   **Answer**: The `vaultTransfer` method is used to transfer a specified amount of tokens from the program vault to a specified account. It takes the `program`, the recipient `to`, the `authority` required to sign the transfer transaction, and a `params` object containing the `stateBump` and the `amount` to transfer as its parameters."
    },
    {
      "fileName": "queueDataBuffer.ts",
      "filePath": "javascript/solana.js/src/accounts/queueDataBuffer.ts",
      "url": "https://github.com/switchboard-xyz/sbv2-solana/blob/master/javascript/solana.js/src/accounts/queueDataBuffer.ts",
      "summary": "The `QueueDataBuffer` class in this code is responsible for managing an account that holds a list of oracles actively heartbeating on the queue. The class extends the `Account` class and is parameterized by an array of `PublicKey` objects, representing the oracles.\n\nThe class provides several methods for working with the queue data buffer:\n\n- `getAccountSize(size: number)`: Returns the account size based on the number of oracles.\n- `default(size = 100)`: Returns a default buffer with the specified size.\n- `createMock(...)`: Creates a mock account info for a given VRF (Verifiable Random Function) configuration, useful for testing purposes.\n- `onChange(...)`: Registers a callback function to be invoked each time the oracle queue buffer changes on-chain.\n- `loadData()`: Retrieves and decodes the data stored in the account.\n- `decode(...)`: Decodes the buffer account info into an array of `PublicKey` objects.\n- `fromQueue(...)`: Returns a queue data buffer from a given oracle queue account data.\n\nFor example, to create a mock account info with a custom size and list of oracles, you can use the `createMock` method:\n\n```javascript\nconst programId = new PublicKey('...');\nconst data = { size: 50, oracles: [new PublicKey('...'), new PublicKey('...')] };\nconst mockAccountInfo = QueueDataBuffer.createMock(programId, data);\n```\n\nTo watch for changes in the queue data buffer and invoke a callback function when the buffer changes, you can use the `onChange` method:\n\n```javascript\nconst callback = (updatedOracles: Array<PublicKey>) => {\n  console.log('Queue data buffer changed:', updatedOracles);\n};\nconst commitment = 'confirmed';\nconst subscriptionId = queueDataBuffer.onChange(callback, commitment);\n```\n\nThese functionalities allow the `sbv2-solana` project to manage and monitor the list of oracles participating in the network, ensuring that the data is up-to-date and accurate.",
      "questions": "1. **Question**: What is the purpose of the `QueueDataBuffer` class and how does it relate to the oracles in the project?\n   **Answer**: The `QueueDataBuffer` class represents an account holding a list of oracles that are actively heartbeating on the queue. It provides methods to create, load, and decode the data related to the oracles, as well as to watch for changes in the oracle queue buffer.\n\n2. **Question**: How does the `onChange` method work and when should it be used?\n   **Answer**: The `onChange` method is used to invoke a callback each time a QueueAccount's oracle queue buffer has changed on-chain. It takes a callback function and an optional commitment parameter (defaulting to 'confirmed'). This method is useful when you want to monitor changes in the oracle queue buffer and react to them in real-time.\n\n3. **Question**: What is the purpose of the `createMock` method and in what scenarios would it be useful?\n   **Answer**: The `createMock` method is used to create a mock account info for a given VRF (Verifiable Random Function) configuration. It is useful for test integrations, allowing developers to create test instances of the `QueueDataBuffer` without interacting with the actual blockchain."
    },
    {
      "fileName": "vrfAccount.ts",
      "filePath": "javascript/solana.js/src/accounts/vrfAccount.ts",
      "url": "https://github.com/switchboard-xyz/sbv2-solana/blob/master/javascript/solana.js/src/accounts/vrfAccount.ts",
      "summary": "The `VrfAccount` class in this code represents an account holding a Verifiable Random Function (VRF) result with a callback instruction for consuming on-chain pseudo-randomness. The class provides methods for creating, loading, and updating VRF accounts, as well as requesting randomness and verifying the result.\n\nThe `createInstructions` and `create` methods are used to create a new VRF account with the specified parameters. The `load` method is used to load an existing VRF account with its current on-chain state. The `onChange` method allows invoking a callback each time a VRF account's data has changed on-chain.\n\nThe `requestRandomnessInstruction` and `requestRandomness` methods are used to request randomness from the VRF account. The `proveAndVerifyInstructions` and `proveAndVerify` methods are used to prove and verify the VRF result.\n\nThe `setCallbackInstruction` and `setCallback` methods are used to set a callback function that is invoked when a new randomness value is produced. The `getCallbackTransactions` method retrieves parsed transactions for a VRF request.\n\nThe `nextResult` method is used to await the next VRF result. The `closeAccountInstruction` and `closeAccount` methods are used to close a VRF account.\n\nThe `VrfAccount` class also provides utility methods for fetching and converting account data to JSON format, as well as requesting and awaiting VRF results.\n\nThis code is part of the larger sbv2-solana project, which uses the Solana blockchain to provide secure and verifiable random numbers. The `VrfAccount` class plays a crucial role in managing VRF accounts and interacting with the on-chain randomness generation process.",
      "questions": "1. **Question**: What is the purpose of the `VrfAccount` class and its methods?\n   **Answer**: The `VrfAccount` class represents an account holding a Verifiable Random Function (VRF) result with a callback instruction for consuming on-chain pseudo-randomness. It provides methods to create, load, and manipulate VRF accounts, request randomness, set callbacks, and interact with related accounts such as oracle queues and permission accounts.\n\n2. **Question**: How does the `requestRandomness` method work and what are its parameters?\n   **Answer**: The `requestRandomness` method creates a transaction object with instructions to request randomness from the VRF account. It takes a `VrfRequestRandomnessParams` object as a parameter, which includes optional authority, payer token wallet, payer authority, queue, queue account, and VRF account data. The method returns a transaction signature after signing and sending the transaction.\n\n3. **Question**: How does the `nextResult` method work and what does it return?\n   **Answer**: The `nextResult` method waits for the next VRF result by monitoring changes in the VRF account's data. It takes an optional round ID and a timeout value as parameters. The method returns a `VrfResult` object containing the success status, result as a Uint8Array, and the VRF status."
    },
    {
      "fileName": "vrfLiteAccount.ts",
      "filePath": "javascript/solana.js/src/accounts/vrfLiteAccount.ts",
      "url": "https://github.com/switchboard-xyz/sbv2-solana/blob/master/javascript/solana.js/src/accounts/vrfLiteAccount.ts",
      "summary": "The `VrfLiteAccount` class in this code is part of the sbv2-solana project and represents a Verifiable Random Function (VRF) Lite account. VRF Lite accounts are used to generate random numbers in a decentralized and verifiable manner. The class provides methods for creating, depositing, proving, verifying, and closing VRF Lite accounts, as well as handling account changes and fetching associated data.\n\nFor example, the `createInstruction` method generates a new VRF Lite account and returns the account along with a transaction object. The `depositInstructions` method creates a transaction object for depositing tokens into the VRF Lite account's associated token wallet. The `proveAndVerifyInstructions` method generates an array of transaction objects for proving and verifying the VRF Lite account's randomness.\n\nThe `awaitRandomness` method allows users to wait for the VRF Lite account's randomness to be generated, with an optional timeout parameter. The `closeAccountInstruction` and `closeAccount` methods provide functionality for closing a VRF Lite account and transferring its funds to a specified destination.\n\nAdditionally, the class includes utility methods like `getPermissionAccount`, which returns a permission account associated with the VRF Lite account, and `getEscrow`, which returns the associated escrow public key.\n\nHere's an example of creating a VRF Lite account:\n\n```javascript\nconst [vrfLiteAccount, txnSignature] = await VrfLiteAccount.create(\n  program,\n  {\n    queueAccount: queueAccountInstance,\n    callback: callbackInstance,\n    expiration: 100,\n    keypair: keypairInstance,\n    authority: authorityPublicKey,\n  }\n);\n```\n\nAnd an example of depositing tokens into the VRF Lite account:\n\n```javascript\nconst txnSignature = await vrfLiteAccount.deposit({\n  tokenWallet: tokenWalletPublicKey,\n  tokenAuthority: tokenAuthorityKeypair,\n  amount: 100,\n});\n```",
      "questions": "1. **Question**: What is the purpose of the `VrfLiteAccount` class and its methods?\n   **Answer**: The `VrfLiteAccount` class represents a VRF Lite account in the sbv2-solana project. It provides methods for creating, depositing, proving and verifying VRF Lite accounts, as well as handling account changes, closing accounts, and managing permissions and escrow.\n\n2. **Question**: How does the `proveAndVerify` method work and what are its parameters?\n   **Answer**: The `proveAndVerify` method sends multiple transactions to prove and verify the VRF Lite account. It takes an object with optional parameters such as `vrfLite`, `proof`, `oraclePubkey`, `oracleTokenWallet`, `oracleAuthority`, and `skipPreflight`. It also accepts optional `options` and `numTxns` parameters to customize the transaction objects.\n\n3. **Question**: How does the `awaitRandomness` method work and what is its purpose?\n   **Answer**: The `awaitRandomness` method listens for changes in the VRF Lite account's state and resolves when the status is either `StatusCallbackSuccess` or `StatusVerified`. It takes an object with a `requestSlot` parameter and an optional `timeout` parameter. The purpose of this method is to wait for the VRF Lite account to generate randomness and return the updated account state."
    },
    {
      "fileName": "vrfPoolAccount.ts",
      "filePath": "javascript/solana.js/src/accounts/vrfPoolAccount.ts",
      "url": "https://github.com/switchboard-xyz/sbv2-solana/blob/master/javascript/solana.js/src/accounts/vrfPoolAccount.ts",
      "summary": "The `VrfPoolAccount` class in this code is responsible for managing a pool of Verifiable Random Function (VRF) accounts in the `sbv2-solana` project. It provides methods to create, push, pop, and request VRF accounts, as well as deposit and fund operations.\n\nThe `VrfPoolAccount` class extends the `Account` class and has a `size` property that represents the size of the VRF pool account data. The `onChange` method allows subscribing to changes in the VRF pool account data with a specified callback and commitment level.\n\nThe `createInstruction` and `create` methods are used to create a new VRF pool account with specified initialization parameters. The `pushNewInstruction` and `pushNew` methods create a new VRF Lite account and push it to the VRF pool. The `pushInstruction` and `push` methods push an existing VRF Lite account to the VRF pool. The `popInstructions` and `pop` methods remove the last VRF Lite account from the pool.\n\nThe `requestInstructions` and `request` methods create a transaction to request a new VRF value from the pool. The `requestAndAwaitEvent` method requests a new VRF value and waits for the corresponding event to be emitted.\n\nThe `depositInstructions` and `deposit` methods allow depositing funds into the VRF pool's escrow account. The `fundUpToInstruction` and `fundUpTo` methods fund the escrow account up to a specified amount.\n\nThe class also provides utility methods like `getRemainingAccounts`, `getPermissionAccount`, `getEscrow`, `fetchBalance`, and `decode` to manage and interact with the VRF pool account data and associated accounts.",
      "questions": "1. **Question**: What is the purpose of the `VrfPoolAccount` class and its methods?\n   **Answer**: The `VrfPoolAccount` class represents a VRF (Verifiable Random Function) pool account in the sbv2-solana project. It provides methods for creating, loading, and managing VRF pool accounts, as well as interacting with the associated queue accounts, VRF lite accounts, and permission accounts.\n\n2. **Question**: How does the `requestAndAwaitEvent` method work and what does it return?\n   **Answer**: The `requestAndAwaitEvent` method sends a request for randomness and waits for a `VrfPoolRequestEvent` to be emitted. It returns a promise that resolves to an array containing the event and the transaction signature of the request.\n\n3. **Question**: How does the `fundUpTo` method work and what does it return?\n   **Answer**: The `fundUpTo` method funds the VRF pool account's escrow up to a specified amount. If the current balance is less than the specified amount, it creates a deposit transaction and sends it. The method returns a promise that resolves to an array containing the transaction signature (if a deposit was made) and the funded amount."
    }
  ],
  "folders": [],
  "summary": "The `.autodoc/docs/json/javascript/solana.js/src/accounts` folder contains various classes and types related to different account types in the `sbv2-solana` project. These account classes are used to interact with on-chain resources, such as oracles, aggregators, and jobs.\n\nFor example, the `AggregatorAccount` class is responsible for managing aggregator accounts that collect and aggregate data from multiple oracles. You can create an `AggregatorAccount` instance and load its associated data from the blockchain as follows:\n\n```javascript\nconst aggregatorAccount = new AggregatorAccount(switchboardProgram, publicKey);\nconst aggregatorData = await aggregatorAccount.loadData();\n```\n\nThe `AggregatorHistoryBuffer` class represents a round-robin buffer of historical samples for an aggregator account. It provides methods to create, decode, and fetch historical data from the buffer. This is useful for tracking the history of data points in an aggregator account, such as price feeds or other time-series data.\n\n```ts\nimport { AggregatorAccount, AggregatorHistoryBuffer } from '@switchboard-xyz/solana.js';\nconst aggregatorAccount = new AggregatorAccount(program, aggregatorKey);\nconst aggregator = await aggregatorAccount.loadData();\nconst [historyBuffer, addHistorySignature] = await AggregatorHistoryBuffer.create(program, {\n   aggregatorAccount,\n   maxSamples: 10000,\n});\nconst history = await historyBuffer.loadData();\n```\n\nThe `CrankAccount` class is responsible for managing a priority queue of aggregators and their next available update time. This scheduling mechanism ensures that `AggregatorAccount`s are updated as close as possible to their specified update interval.\n\n```javascript\nconst [crankAccount, txnSignature] = await CrankAccount.create(\n  program,\n  {\n    queueAccount: queueAccountInstance,\n    name: 'exampleCrank',\n    metadata: 'exampleMetadata',\n    maxRows: 500,\n  }\n);\n```\n\nThe `PermissionAccount` class is responsible for managing permissions between a granter and a grantee in the sbv2-solana project. It is used to dictate the level of permissions between these two entities.\n\n```javascript\nconst [account, txSignature] = await PermissionAccount.create(program, {\n  granter: granterPublicKey,\n  grantee: granteePublicKey,\n  authority: authorityPublicKey,\n});\n```\n\nThese account classes and types are essential for managing and interacting with on-chain resources in the `sbv2-solana` project, a decentralized oracle network built on the Solana blockchain.",
  "questions": ""
}